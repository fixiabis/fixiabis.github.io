<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title></title>
    <script src="js/Board.js"></script>
    <script src="js/ViewableBoard.js"></script>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0px;
        }
    </style>
</head>

<body>
    <script>
        var board = new ViewableBoard(11, 11, document.body),
            gameRecord = [],
            turn = 1,
            record = [],
            analysisRecord = {},
            relati = {
                root: {},
                dead: [],
                battle: [],
                relati: {},
                domain: {},
                prevJudge: []
            },
            isRelati = function (grid, sym, needList) {
                if (relati.prevJudge.indexOf(grid.crd) > -1 && !needList) return true;
                var relatiCrd = [],
                    gridO = grid.getGridsByRelCrd("O"),
                    grid2O = grid.getGridsByRelCrd("2O"),
                    gridQ = grid.getGridsByRelCrd("IIH,IHH"),
                    isOwner = grid => grid && grid._.symbol == sym && grid._.status != "dead",
                    isSpace = grid => grid && (grid._.symbol == "" || grid._.status == "dead");
                for (var i = 0; i < gridO.length; i++)
                    if (isOwner(gridO[i]))
                        relatiCrd.push(gridO[i].crd);
                for (var i = 0; i < grid2O.length; i++) {
                    if (!isOwner(grid2O[i])) continue;
                    if (isSpace(gridO[i]))
                        relatiCrd.push(grid2O[i].crd);
                }
                for (var i = 0; i < gridQ.length; i++) {
                    if (!isOwner(gridQ[i])) continue;
                    var relCrd = grid.getRelCrdByGrid(gridQ[i]),
                        SVGrid = grid.getGridByRelCrd(relCrd.replace(/2./, "")),
                        DVGrid = grid.getGridByRelCrd(relCrd.replace(/1./, "")),
                        DSVGrid = grid.getGridByRelCrd(relCrd.replace(/1./, "").replace("2", "1")),
                        HVGrid = grid.getGridByRelCrd(relCrd.replace("2", "1").replace(/1/g, ""));
                    if ((isSpace(HVGrid) && (isSpace(SVGrid) || isSpace(DSVGrid))) || isSpace(DSVGrid) && isSpace(DVGrid))
                        relatiCrd.push(gridQ[i].crd);
                }
                if (needList) return relatiCrd;
                return relatiCrd.length > 0;
            },
            isBranch = function (grid, sym) {
                var relCrd = ["F", "B", "R", "L", "FR", "BR", "FL", "BL"];
                for (var i = 0; i < relCrd.length; i++)
                    for (var j = 1; j < 15; j++) {
                        var gridX = grid.getGridByRelCrd(j + relCrd[i]);
                        if (!gridX) break;
                        if (gridX._.symbol == "") continue;
                        if (gridX._.symbol != sym) break;
                        if (gridX._.symbol == sym && gridX._.status != "dead") return true;
                    }
                return false;
            },
            isBattle = function (grid, sym, needList) {
                var relCrd = ["F", "B", "R", "L", "FR", "BR", "FL", "BL"],
                    battleCrd = [];
                for (var i = 0; i < relCrd.length; i++) {
                    var j = 1;
                    while (true) {
                        var gridX = grid.getGridByRelCrd(j + relCrd[i]);
                        if (!gridX || gridX._.symbol == "" || (gridX._.symbol != sym && gridX._.status != "dead")) break;
                        if (gridX._.symbol == sym && gridX._.status != "dead") {
                            var gridX2 = grid.getGridByRelCrd((j + 1) + relCrd[i]);
                            if (!gridX2) break;
                            if (gridX2._.symbol == sym && gridX2._.status != "dead") {
                                if (!needList) {
                                    gridX2._.status = "select";
                                    relati.battle.push(gridX2.crd);
                                }
                                battleCrd.push(gridX2.crd);
                                break;
                            }
                        }
                        j++;
                    }
                }
                if (needList) return battleCrd;
                return battleCrd.length > 0;
            },
            relatiTree = function (grid, sym, parent) {
                var relatiCrd = isRelati(grid, sym, true);
                if (relati.relati[sym].indexOf(grid.crd) > -1) return;
                relati.relati[sym].push(grid.crd);
                relati.relati.all.push(grid.crd);
                for (var i = 0; i < relatiCrd.length; i++)
                    relatiTree(board.grids[relatiCrd[i]], sym, grid);
            },
            resetJudge = function () {
                for (var i in board.grids) {
                    board.grids[i]._.status = "";
                    board.grids[i]._.area = "";
                    board.grids[i]._.dead = "";
                }
            },
            battleJudge = function () {
                for (var i = 0; i < relati.dead.length; i++) {
                    board.grids[relati.dead[i]]._.status = "dead";
                    board.grids[relati.dead[i]]._.dead = "battle";
                }
                for (var i = 0; i < relati.battle.length; i++)
                    board.grids[relati.battle[i]]._.status = "select";
            },
            branchJudge = function () {
                var rootCrd = [
                    record.indexOf(relati.root.O),
                    record.indexOf(relati.root.X)
                ];
                for (var i = 0; i < record.length; i++) {
                    if (i >= rootCrd[i % 2] || !board.grids[record[i]]) continue;
                    board.grids[record[i]]._.status = "dead";
                }
            },
            relatiJudge = function () {
                relati.relati = { all: [], O: [], X: [] };
                relati.prevJudge = [];
                for (var sym in relati.root) {
                    if (board.grids[relati.root[sym]]._.status == "dead") continue;
                    board.grids[relati.root[sym]]._.status = "root";
                    relatiTree(board.grids[relati.root[sym]], sym);
                }
                var noRelatiFirst = false;
                for (var i = 0; i < record.length; i++) {
                    var sym = i % 2 == 0 ? "O" : "X",
                        crd = record[i];
                    if (!board.grids[crd] || board.grids[crd]._.status == "root") continue;
                    if (relati.relati.all.indexOf(crd) == -1) {
                        var noRelati = true;
                        if (!noRelatiFirst) noRelatiFirst = true;
                        else {
                            var relatiCrd = isRelati(board.grids[crd], sym, true);
                            for (var j = 0; j < relatiCrd.length; j++)
                                if (relati.relati[sym].indexOf(relatiCrd[j].crd) > -1) {
                                    noRelati = false;
                                    relatiTree(board.grids[crd], sym);
                                    break;
                                }
                        }
                        if (noRelati) {
                            var grid = board.grids[crd];
                            grid._.status = "dead";
                        }
                    }
                }
            },
            domainJudge = function () {
                var space = { O: [], X: [], P: [], N: [], all: [], visited: [], area: [] },
                    sym = turn % 2 == 0 ? "X" : "O",
                    prevJudge = [];
                relati.domain = { O: [], X: [] };
                for (var i in relati.domain)
                    for (var crd in board.grids) {
                        var grid = board.grids[crd];
                        if (grid._.symbol != "") continue;
                        if (space.all.indexOf(crd) < 0)
                            space.all.push(crd);
                        var isRelatiGrid = isRelati(grid, i),
                            isBranchGrid = isBranch(grid, i)
                        if (isRelatiGrid || isBranchGrid) {
                            if (isRelatiGrid && i == sym) prevJudge.push(crd);
                            space[i].push(crd);
                            if (i == "X" && space.O.indexOf(crd) > -1)
                                space.P.push(crd);
                        } else space.N.push(crd);
                    }
                relati.prevJudge = prevJudge;
                if (prevJudge.length == 0)
                    alert((sym == "O" ? "X" : "O") + "贏了");
                for (var i in relati.domain)
                    space[i] = space[i].filter(crd => space.P.indexOf(crd) < 0);
                for (var i = 0; i < space.all.length; i++)
                    spaceAreaTree(board.grids[space.all[i]], space, -1);
                for (var i = 0; i < space.area.length; i++) {
                    var belong = ""
                    P: for (var j = 0; j < space.area[i].length; j++)
                        for (var sym in relati.domain)
                            if (space[sym].indexOf(space.area[i][j]) > -1) {
                                if (belong == "")
                                    belong = sym;
                                else if (belong != sym) {
                                    belong = "P"
                                    break P;
                                }
                            } else if (space.P.indexOf(space.area[i][j]) > -1) {
                                belong = "P";
                                break P;
                            }
                    if (belong != "P" && belong != "")
                        relati.domain[belong] = relati.domain[belong].concat(space.area[i]);
                }
                for (var sym in relati.domain)
                    for (var i = 0; i < relati.domain[sym].length; i++)
                        board.grids[relati.domain[sym][i]]._.area = sym;
            },
            spaceAreaTree = function (grid, space, index) {
                if (space.visited.indexOf(grid.crd) > -1) return;
                space.visited.push(grid.crd);
                if (index == -1) {
                    index = space.area.length;
                    space.area.push([grid.crd]);
                } else space.area[index].push(grid.crd);
                var gridO = grid.getGridsByRelCrd("O");
                for (var i = 0; i < gridO.length; i++)
                    if (gridO[i] && gridO[i]._.symbol == "")
                        spaceAreaTree(gridO[i], space, index);
            },
            recordBoard = function () {
                var newRecord = {
                    turn: turn,
                    record: [],
                    relati: {
                        root: {
                            O: relati.root.O,
                            X: relati.root.X
                        },
                        dead: [],
                        battle: []
                    },
                    boardGrid: {}
                };
                for (var i = 0; i < record.length; i++)
                    newRecord.record.push(record[i]);
                for (var i = 0; i < relati.dead.length; i++)
                    newRecord.relati.dead.push(relati.dead[i]);
                for (var i = 0; i < relati.battle.length; i++)
                    newRecord.relati.battle.push(relati.battle[i]);
                for (var i in board.grids)
                    newRecord.boardGrid[i] = board.grids[i]._.symbol; 1
                gameRecord.push(newRecord);
            },
            analysis = function () {
                var relatiable = { O: [], X: [], P: [] },
                    battleable = { O: [], X: [] },
                    point = {
                        relati: { O: 0, X: 0 },
                        domain: { O: relati.domain.O.length, X: relati.domain.X.length },
                        battle: { O: 0, X: 0 }
                    };
                for (var crd in board.grids) {
                    if (board.grids[crd]._.symbol == "") {
                        var syms = "OX";
                        for (var i = 0; i < syms.length; i++)
                            if (isRelati(board.grids[crd], syms[i], true).length > 0)
                                relatiable[syms[i]].push(crd);
                    } else {
                        var sym = board.grids[crd]._.symbol == "O" ? "X" : "O";
                        if (isBattle(board.grids[crd], sym, true).length > 0)
                            battleable[sym].push(crd);
                    }
                }
                relatiable.P = relatiable.O.filter(crd => relatiable.X.indexOf(crd) > -1);
                relatiable.O = relatiable.O.filter(crd => relatiable.P.indexOf(crd) < 0);
                relatiable.X = relatiable.X.filter(crd => relatiable.P.indexOf(crd) < 0);
                point.relati.O = relatiable.O.length;
                point.relati.X = relatiable.X.length;
                point.battle.O = battleable.O.length;
                point.battle.X = battleable.X.length;
                var type = ["domain", "relati", "battle"],
                    typeName = ["領地", "連線", "戰鬥"],
                    logData = "";
                for (var i = 0; i < type.length; i++) {
                    logData += typeName[i] + "方面:";
                    if (point[type[i]].O == point[type[i]].X)
                        logData += "勢均力敵";
                    else if (point[type[i]].O > point[type[i]].X)
                        logData += `O方優先${point[type[i]].O - point[type[i]].X}點`;
                    else
                        logData += `X方優先${point[type[i]].X - point[type[i]].O}點`;
                    logData += "\n";
                }
                console.log(logData);
                if (analysisRecord) {

                } else analysisRecord = {
                    relati: point.relati,
                    domain: point.domain,
                    battle: point.battle
                }
            };
        board.ongridclick = function (grid) {
            var sym = turn % 2 == 0 ? "X" : "O",
                boardIsChange = true;
            if (grid._.symbol != "") {
                if (grid._.symbol == sym) {
                    if (relati.battle.indexOf(grid.crd) < 0) return;
                    for (var i = 0; i < relati.battle.length; i++)
                        board.grids[relati.battle[i]]._.status = "";
                    grid._.status = "dead";
                    relati.dead.push(grid.crd);
                    record[record.length - 1] += "-" + grid.crd;
                    relati.battle = [];
                    turn++;
                } else if (isBattle(grid, sym)) {
                    grid._.status = "dead";
                    relati.dead.push(grid.crd);
                    record.push(grid.crd);
                } else boardIsChange = false;
            } else if (relati.battle.length < 1) {
                if (isRelati(grid, sym) || turn < 3) {
                    if (turn < 3) {
                        relati.root[sym] = grid.crd;
                        grid._.status = "root";
                    }
                    grid._.symbol = sym;
                    record.push(grid.crd);
                    turn++;
                } else if (isBranch(grid, sym)) {
                    grid._.status = "root";
                    relati.root[sym] = grid.crd;
                    grid._.symbol = sym;
                    record.push(grid.crd);
                    turn++;
                } else boardIsChange = false;
            } else boardIsChange = false;
            if (boardIsChange) {
                recordBoard();
                resetJudge();
                if (turn > 2) {
                    branchJudge();
                    battleJudge();
                    relatiJudge();
                    domainJudge();
                    analysis();
                }
                board.refresh();
            }

        };
        window.onkeydown = function (event) {
            if (event.which == 90 && event.ctrlKey) {
                var oldRecord = gameRecord.pop();
                if (oldRecord.turn == turn)
                    oldRecord = gameRecord.pop();
                if (!oldRecord) return;
                for (var i in oldRecord.relati)
                    relati[i] = oldRecord.relati[i];
                record = oldRecord.record;
                turn = oldRecord.turn;
                for (var i in oldRecord.boardGrid)
                    board.grids[i]._.symbol = oldRecord.boardGrid[i];
                resetJudge();
                if (turn > 2) {
                    branchJudge();
                    battleJudge();
                    relatiJudge();
                    domainJudge();
                }
                board.refresh();
            }
        };
        board.setStatusMark("status", "", painter => painter.strokeStyle = "black");
        board.setStatusMark("status", "dead", painter => painter.strokeStyle = "red");
        board.setStatusMark("status", "root", painter => painter.strokeStyle = "blue");
        board.setStatusMark("status", "select", painter => painter.strokeStyle = "orange");
        board.setStatusMark("dead", "", painter => painter.strokeStyle = painter.strokeStyle);
        board.setStatusMark("dead", "battle", painter => painter.strokeStyle = "brown");
        board.setStatusMark("area", "", function (painter, size, x, y) {
            painter.clearRect(x - 1, y - 1, size, size);
        });
        board.setStatusMark("area", "O", function (painter, size, x, y) {
            painter.fillStyle = "indianred";
            painter.fillRect(x - 1, y - 1, size, size);
        });
        board.setStatusMark("area", "X", function (painter, size, x, y) {
            painter.fillStyle = "lightblue";
            painter.fillRect(x - 1, y - 1, size, size);
        });
        board.setStatusMark("symbol", "O", function (painter, size, x, y) {
            if (size > 25) {
                size -= 20;
                x += 10;
                y += 10;
            } else if (size > 15) {
                size -= 10;
                x += 5;
                y += 5;
            }
            x -= 1;
            y -= 1;
            var halfSize = size / 2;
            painter.lineWidth = 2;
            painter.beginPath();
            painter.arc(x + halfSize, y + halfSize, halfSize, 0 * Math.PI, 2 * Math.PI);
            painter.stroke();
            painter.closePath();
            painter.lineWidth = 1;
            painter.strokeStyle = "black";
        });
        board.setStatusMark("symbol", "X", function (painter, size, x, y) {
            if (size > 25) {
                size -= 20;
                x += 10;
                y += 10;
            } else if (size > 15) {
                size -= 10;
                x += 5;
                y += 5;
            }
            x -= 1;
            y -= 1;
            painter.lineWidth = 2;
            painter.beginPath();
            painter.moveTo(x, y);
            painter.lineTo(x + size, y + size);
            painter.stroke();
            painter.closePath();
            painter.beginPath();
            painter.moveTo(x, y + size);
            painter.lineTo(x + size, y);
            painter.stroke();
            painter.closePath();
            painter.lineWidth = 1;
            painter.strokeStyle = "black";
        });
        board.setStatusOrder("area", "status", "dead", "symbol");
        for (var i in board.grids) {
            board.grids[i]._.status = "";
            board.grids[i]._.symbol = "";
        }
        board.refresh();
    </script>
</body>

</html>